<html><head><title>GO程序</title></head><body><ol><li>GO程序<ol><li>调度器的初始化<ol><li>从硬盘读入内存</li><li>创建进程和主线程</li><li>为主线程分配栈空间</li><li>用户命令行输入的参数拷贝到栈</li><li>主线程挂入操作系统的运行队列等待被调度</li><li>初始化全局变量g0<ol><li>g0的作用提供一个栈空间供runtime运行</li></ol></li><li>主线程与m0和g0的关联<p>主线程和m0的关联通过线程本地存储
m0和g0的绑定，把g0的地址赋于主线程的线程本地存储</p><ol><li>通过settle函数验证TLS功能是否正常<p>通过arch_prctl系统调用把m0.tls[1]的地址设置成了fs段的段基址</p></li><li>线程本地存储的值为指向g0的指针</li></ol></li><li>m0的初始化<ol><li>schedinit函数<p>getg函数是编译器实现，可以从线程本地存储中获取当前正在运行的g
mcommoninit函数对m0(g0.m)进行必要的初始化（把m0放入到全局链表allm中之后返回）</p><ol><li>getg函数</li><li>mcommoninit函数</li><li>procresize（此时m0、g0和m需要的p完全关联在一起）<ol><li>初始化系统需要用到的p结构体对象保存在allp中</li><li>m0和allp[0]绑定在一起</li><li>把除了allp[0]之外的所有p放入到全局变量sched的pidle空闲队列</li></ol></li></ol></li></ol></li></ol></li><li>main goroutine的创建<ol><li>newproc函数<p>参数一：fn函数的参数以字节为单位的大小
参数二：参数fn，新创建出来的goroutine将从fn这个函数开始执行</p><ol><li>调用通用的newproc1函数<p>参数一：入口函数的地址
参数二：入口函数的第一个参数的地址
参数三：入口函数的参数以字节为单位的大小

在初始化加载完成的情况下不需要切换g0栈（本身就在g0栈）
用户使用 go 开启新的goroutine时需要使用systemstack函数切换到g0
该函数运行在g0栈</p><ol><li>从堆上分配一个g结构体对象并为其分配一个大小为2K的栈以及栈的成员赋值；
把这个g需要执行的函数的参数从执行newproc函数的栈（g0）拷贝到这个g的栈</li><li>初始化g的sched成员，保存了调度器代码在调度goroutine到CPU的必要信息<p>sched的sp成员表示newg被调度起来运行时应该使用的栈的栈顶
sched的pc成员表示当newg被调度起来运行时从这个地址开始执行指令</p><ol><li>sched.pc设置为goexit函数而不是 fn 函数的地址</li></ol></li><li>调用gostartcallfn<ol><li>调用gostartcall函数<ol><li>调整g的栈空间，把goexit函数的第二条指令入栈，伪造goexit调用fn，
方便fn执行完成后执行RET指令时返回到goexit继续执行清理工作</li><li>重新设置 g.buf.pc 为需要执行的函数 fn的地址，该场景下为 runtime.main</li><li>修改 g 的状态为_Grunnable并放入运行队列</li><li>此时 g 的成员 m 还未进行设置，因为还未被调度运行</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>调度main goroutine运行<p>保存g0的调度信息，主要是保存CPU栈顶寄存器SP到g0.sched.sp成员之中；
调用schedule函数寻找需要运行的goroutine，我们这个场景找到的是main goroutine;
调用gogo函数首先从g0栈切换到main goroutine的栈，然后从main goroutine的g结构体对象之中取出sched.pc的值并使用JMP指令跳转到该地址去执行；
main goroutine执行完毕直接调用exit系统调用退出进程。</p><ol><li>mstart<ol><li>调用mstart1<ol><li>调用save：保存g0的调度信息<p>函数功能：保存了调度相关的所有信息，包括最为重要的当前正在运行的g的下一条指令的地址和栈顶地址，不管是对g0还是其它goroutine来说这些信息在调度过程中都是必不可少</p></li></ol></li></ol></li><li>runtime.main函数<ol><li>启动sysmon系统监控线程，负责gc、抢占调度以及netpoll等功能</li><li>runtime包初始化</li><li>执行main包以及main包的import所有包的初始化</li><li>执行main.main函数</li><li>从main.mian函数返回后调用exit系统调用退出进程<p>对于main goroutine会直接exit，而非main goroutine执行完成后就会返回到goexit继续执行进行一些清理工作</p></li></ol></li></ol></li><li>非main goroutine的退出<ol><li>RET返回调用goexit<ol><li>调用goexit1<ol><li>调用mcall
切换回g0栈，在g0栈上调用goexit0这个函数<p>属于runtime逻辑代码，使用mcall是已经从用户g切换到了g0上，切换到g0.sched.sp固定位置不会造成栈溢出的情况

函数功能：
先从当前运行的g(我们这个场景是g2)切换到g0，这一步包括保存当前g的调度信息，把g0设置到tls中，修改CPU的rsp寄存器使其指向g0的栈；
以当前运行的g(我们这个场景是g2)为参数调用fn函数(此处为goexit0)。</p><ol><li>goexit0函数执行清理工作<ol><li>把用户g状态从 _Grunning 变更为 _Gdead</li><li>用户g的一些字段清空为0值</li><li>调用dropg解除用户g和m之间的关系，g-&gt;m = nil, m-&gt;currg = nil</li><li>把g放入到p的freeg队列缓存供下次创建g时获取而不用从内存分配。freeg为goroutine的一个对象池</li><li>调用schedule函数</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>调度策略<ol><li>调度发生的条件<ol><li>goroutine因为某个操作条件不满足（channel阻塞，网络连接阻塞，加锁阻塞或select操作阻塞）需要等待而发生调度</li><li>goroutine主动调用Gosched函数让CPU发生调度</li><li>Goroutine运行时间太长或长时间处于系统调用而被调度器剥夺运行权而发生调度</li></ol></li><li>被动调度<ol><li>读取channel阻塞而发生被动调度<p>读取channel调用runtime.chanrecv1函数

chanrecv1直接调用chanrecv函数实现读取操作，chanrecv首先会判断channel是否有数据可读，如果有数据则直接读取并返回，但如果没有数据，则需要把当前goroutine挂入channel的读取队列之中并调用goparkunlock函数阻塞该goroutine

goparkunlock函数直接调用gopark函数，gopark则调用mcall从当前main goroutine切换到g0去执行park_m函数</p><ol><li>runtime.chanrecv1—chanrecv—goparkunlock(阻塞当前goroutine)—gopark—mcall(切换到g0)—park_m</li><li>park_m<p>park_m首先把当前goroutine的状态设置为_Gwaiting（因为它正在等待其它goroutine往channel里面写数据），然后调用dropg函数解除g和m之间的关系，最后通过调用schedule函数进入调度循环</p></li></ol></li><li>唤醒阻塞在channel上的goroutine<p>channel的发送操作是对runtime.chansend1函数的调用

channel发送和读取的流程类似，如果能够立即发送则立即发送并返回，如果不能立即发送则需要阻塞，如果有正挂在channel的读取队列上等待数据，所以这里直接调用send函数发送给待读取的g，send函数则调用goready函数切换到g0栈并调用ready函数来唤醒正在等待读的goroutine</p><ol><li>runtime.chansend1—chansend—goready(切换到g0)—ready(唤醒)</li><li>ready<p>ready函数首先把需要唤醒的goroutine的状态设置为_Grunnable，然后把其放入运行队列之中等待调度器的调度

如果当前有空闲的p而且没有处于spinning状态的工作线程，那么就需要通过wakep函数把空闲的p唤醒起来工作</p><ol><li>wakeup<p>首先通过cas操作再次确认是否有其它工作线程正处于spinning状态

如果已经有工作线程进入了spinning状态而在四处寻找需要运行的goroutine，就没有必要再启动一个多余的工作线程出来了</p><ol><li>如果cas操作成功则调用startm创建一个新的或唤醒一个处于睡眠状态的工作线程</li><li>startm<p>首先判断是否有空闲的p结构体对象，如果没有则直接返回，如果有则需要创建或唤醒一个工作线程出来与之绑定

在确保有可以绑定的p对象之后，首先尝试从m的空闲队列中查找正处于休眠状态的工作线程，如果找到则通过notewakeup函数唤醒它，否则调用newm函数创建一个新的工作线程</p><ol><li>notewakeup<p>工作线程会通过notesleep函数睡眠在m.park成员上，所以notewakeup使用m.park成员作为参数把睡眠在该成员之上的工作线程唤醒

首先使用atomic.Xchg设置note.key值为1，然后notewakeup函数继续调用futexwakeup函数

futexwakeup调用包装了futex系统调用的futex函数来实现唤醒睡眠在内核中的工作线程。</p></li><li>nwem<p>首先调用allocm函数从堆上分配一个m结构体对象，然后调用newm1函数，newm1继续调用newosproc函数，newosproc的主要任务是调用clone函数创建一个系统线程，新建的这个系统线程将从mstart函数开始运行</p><ol><li>allocm从堆上申请一个m结构体对象<ol><li>newm1—newosproc—clone<ol><li>clone<p>clone函数首先用了4条指令为clone系统调用准备参数，该系统调用一共需要四个参数，根据Linux系统调用约定，这四个参数需要分别放入rdi， rsi，rdx和r10寄存器中，这里最重要的是第一个参数和第二个参数，分别用来指定内核创建线程时需要的选项和新线程应该使用的栈。因为即将被创建的线程与当前线程共享同一个进程地址空间，所以这里必须为子线程指定其使用的栈，否则父子线程会共享同一个栈从而造成混乱，从上面的newosproc函数可以看出，新线程使用的栈为m.g0.stack.lo～m.g0.stack.hi这段内存，而这段内存是newm函数在创建m结构体对象时从进程的堆上分配而来的。

准备好系统调用的参数之后，还有另外一件很重的事情需要做，那就是把clone函数的其它几个参数（mp, gp和线程入口函数）保存到寄存器中，之所以需要在系统调用之前保存这几个参数，原因在于这几个参数目前还位于父线程的栈之中，而一旦通过系统调用把子线程创建出来之后，子线程将会使用我们在clone系统调用时给它指定的栈，所以这里需要把这几个参数先保存到寄存器，等子线程从系统调用返回后直接在寄存器中获取这几个参数。这里要注意的是虽然这个几个参数值保存在了父线程的寄存器之中，但创建子线程时，操作系统内核会把父线程的所有寄存器帮我们复制一份给子线程，所以当子线程开始运行时就能拿到父线程保存在寄存器中的值，从而拿到这几个参数。这些准备工作完成之后代码调用syscall指令进入内核，由内核帮助我们创建系统线程。

新工作线程的初始化完成之后，便开始执行mstart函数，mstart函数首先会去设置m.g0的stackguard成员，然后调用mstart1()函数把当前工作线程的g0的调度信息保存在m.g0.sched成员之中，最后通过调用schedule函数进入调度循环。

clone函数会返回两次，在子线程返回值为0继续执行子线程的代码，父线程返回值为子线程的线程ID保存到栈最后通过RET指令最为newosproc的返回值

首先通过系统调用获取到子线程的线程id，并赋值给m.procid，然后调用settls设置线程本地存储并通过把m.g0的地址放入线程本地存储之中，从而实现了m结构体对象与工作线程之间的关联</p></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li>主动调度<ol><li>主动调用runtime.Gsched<ol><li>macall<p>保存调用Gosched的goroutine的现场信息
把保存在g0的sched.sp和sched.bp字段的值恢复到CPU的rsp和rbp寄存器，由此完成g2的栈到g0栈的切换
在g0栈执行goched_m函数。（gosched_m函数是runtime.Gosched函数调用mcall时传递给mcall的参数）。</p><ol><li>g0栈上运行gosched_m<ol><li>调用goshedlmpl：接收一个g指针类型<p>把主动调度的goroutine（即调用runtime.sched的g）的状态从 _Grunning 设置为 _Grunnable，通过dropg函数解除当前工作线程m和g的关系，然后调用globrunqput函数把主动调度的g放入全局队列中</p><ol><li>调用schedule进入调度循环</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>抢占调度<ol><li>sysmon监控线程每10毫秒调用retake函数<ol><li>retake函数<ol><li>只有P的状态处于_Prunning和_Psyscall时才会发生抢占<ol><li>_Psyscall：goroutine正在内核进行系统调用，此时需要多个条件进行判断是否需要抢占，实际上是剥夺工作线程绑定的p<ol><li>判断条件<ol><li>P的运行队列里有等待运行的gortoutine<p>这用来保证当前p的本地运行队列中的goroutine得到及时的调度，因为该p对应的工作线程正处于系统调用之中，无法调度队列中goroutine，所以需要寻找另外一个工作线程来接管这个p从而达到调度这些goroutine的目的</p></li><li>没有空闲的p<p>表示其它所有的p都已经与工作线程绑定且正忙于执行go代码，这说明系统比较繁忙，所以需要抢占当前正处于系统调用之中而实际上系统调用并不需要的这个p并把它分配给其它工作线程去调度其它goroutine。</p></li><li>P对应的m处于系统调用中超过10毫秒<p>这表示只要系统调用超时，就对其抢占，而不管是否真的有goroutine需要调度，这样保证sysmon线程不至于觉得无事可做（sysmon线程会判断retake函数的返回值，如果为0，表示retake并未做任何抢占，所以会觉得没啥事情做）而休眠太长时间最终会降低sysmon监控的实时性</p></li></ol></li><li>CAS条件：通过cas修改p的状态来获取p的使用权，因为工作线程可能正好从系统调用返回也正在获取p的使用权</li><li>使用权获取成功，调用handoffp寻找新的工作线程接管P<ol><li>handoffp<p>通过各种条件判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列</p><ol><li>需要启动新的线程的情况<ol><li>_p_的本地运行队列或全局运行队列有待运行的gorroutine</li><li>需要帮助gc完成标记工作</li><li>所有其他_p_都在运行goroutine</li><li>所有其他_p_都处于空闲状态，但是需要监控网络连接读写事件，需要创建新的m来poll网络连接</li></ol></li></ol></li></ol></li><li>系统调用<ol><li>调用Syscall6函数<p>主要内容：
调用runtime.entersyscall函数；
使用SYSCALL指令进入系统调用；
调用runtime.exitsyscall函数。</p><ol><li>系统调用之前：entersyscall函数<ol><li>调用reentersyscall：保存现场信息解除m和p的绑定关系修改p的状态为_Psyscall<p>主动解除m和p的绑定关系之后，sysmon线程就不需要通过加锁或cas操作来修改m.p成员从而解除m和p之间的关系；
记录进入系统调用之前的g可以让工作线程从系统调用返回之后快速找到一个可能可用的p，而不需要加锁从sched的pidle全局队列中去寻找空闲的p</p></li></ol></li><li>系统调用：SYSCALL</li><li>系统调用之后：exitsyscall函数<ol><li>首先调用exitsyscallfast尝试绑定一个空闲的p<ol><li>exitsyscallfast<ol><li>首先尝试绑定进入系统调用之前的p</li><li>绑定失败调用exitsyscallfast_pidle获取空闲的p来绑定<p>从p的全局空闲队列中获取一个p出来绑定，获取过程需要加锁控制

注意这里使用了systemstack(func())函数来调用exitsyscallfast_pidle，systemstack(func())函数有一个func()类型的参数，该函数首先会把栈切换到g0栈，然后调用通过参数传递进来的函数(这里是一个闭包，包含了对exitsyscallfast_pidle函数的调用)，最后再切换回原来的栈并返回

原则上来说，只要调用链上某个函数有nosplit这个编译器指示就需要在g0栈上去执行，因为有nosplit指示的话编译器就不会插入检查溢出的代码，这样在非g0栈上执行这些nosplit函数就有可能导致栈溢出，g0栈其实就是操作系统线程所使用的栈，它的空间比较大，不需要对runtime代码中的每个函数都做栈溢出检查，否则会严重影响效率。</p></li></ol></li></ol></li><li>绑定不成功则调用mcall函数切换到g0栈执行exitsyscall0函数<ol><li>exitsyscall0<ol><li>再次尝试从全局空闲队列获取一个p进行绑定，然后通过excute函数继续执行goroutine</li><li>找不到空闲的p则把当前goroutine放入全局运行队列，由其他工作线程负责调度运行，自己调用stopm进入睡眠</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li>_Prunning：如果运行时间超过10毫秒则进行抢占<ol><li>preemptone函数发出抢占请求<p>preemptone函数只是简单的设置了被抢占goroutine对应的g结构体中的 preempt成员为true和stackguard0成员为stackPreempt（stackPreempt是一个常量，一个非常大的数）</p></li><li>处理抢占请求<ol><li>调用链：morestack_noctxt()-&gt;morestack()-&gt;newstack()<p>main函数的第三条指令jbe指令跳转，jbe条件跳转指令，根据g结构体中的stackguard0的值与栈顶寄存器rsp的值比较是否比stackguard0的值小以此来判断是否需要扩展或被抢占调度，如果发现stackguard0被设置为抢占标记则执行call指令调用morestack_noctxt()

morestack_noctxt()使用jmp指令直接跳转至morestack继续执行，morestack会被编译器自动插入到函数序言(prologue)</p><ol><li>保存调用morestack函数的goroutine的调度信息保存到对应g结构体成员sched中</li><li>切换到当前工作线程的g0栈继续执行newstack函数</li></ol></li><li>newstack函数<p>功能：扩栈、响应sysmon提出的抢占请求</p><ol><li>检查g.stackguard0如果可以被抢占<ol><li>调用gopreempt_m函数<ol><li>调用goschedlmpl函数完成调度切换工作</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li>schedu函数<ol><li>从全局队列获取<p>为了保证调度的公平性，每个工作线程每经过61次调度就需要优先尝试从全局运行队列中找出一个goroutine来运行
全局运行队列是所有工作线程都可以访问的，所以在访问它之前需要加锁</p><ol><li>globrunqget函数： 
参数一：当前工作线程绑定的p 
参数二：max最多可以从全局队列中拿多少g<p>进行负载均衡

//根据p的数量平分全局运行队列中的goroutines
    n := sched.runqsize / gomaxprocs + 1
    if n &gt; sched.runqsize { //上面计算n的方法可能导致n大于全局运行队列中的goroutine数量
        n = sched.runqsize
    }
    if max &gt; 0 &amp;&amp; n &gt; max {
        n = max   //最多取max个goroutine
    }
    if n &gt; int32(len(_p_.runq)) / 2 {
        n = int32(len(_p_.runq)) / 2  //最多只能取本地队列容量的一半
    }</p></li></ol></li><li>从本地运行队列获取<p>首先查看runnext成员是否为空，如果不为空则返回runnext所指的goroutine，并把runnext成员清零，如果runnext为空，则继续从循环队列中查找goroutine</p><ol><li>P<ol><li>本地无锁循环队列：最多包含256个goroutine<ol><li>runq</li><li>runqhead</li><li>runqtail</li></ol></li><li>runnext成员：指向 g 结构体对象最多只包含一个goroutine</li></ol></li><li>CAS操作：必要性在获取可运行g的过程中可能有其他工作线程正在窃取<p>对runqhead的操作使用了atomic.LoadAcq和atomic.CasRel，它们分别提供了load-acquire和cas-release语义。
对于atomic.LoadAcq来说，其语义主要包含如下几条：
原子读取，也就是说不管代码运行在哪种平台，保证在读取过程中不会有其它线程对该变量进行写入；
位于atomic.LoadAcq之后的代码，对内存的读取和写入必须在atomic.LoadAcq读取完成后才能执行，编译器和CPU都不能打乱这个顺序；
当前线程执行atomic.LoadAcq时可以读取到其它线程最近一次通过atomic.CasRel对同一个变量写入的值，与此同时，位于atomic.LoadAcq之后的代码，不管读取哪个内存地址中的值，都可以读取到其它线程中位于atomic.CasRel（对同一个变量操作）之前的代码最近一次对内存的写入。
对于atomic.CasRel来说，其语义主要包含如下几条：
原子的执行比较并交换的操作；
位于atomic.CasRel之前的代码，对内存的读取和写入必须在atomic.CasRel对内存的写入之前完成，编译器和CPU都不能打乱这个顺序；
线程执行atomic.CasRel完成后其它线程通过atomic.LoadAcq读取同一个变量可以读到最新的值，与此同时，位于atomic.CasRel之前的代码对内存写入的值，可以被其它线程中位于atomic.LoadAcq（对同一个变量操作）之后的代码读取到。</p></li></ol></li><li>从其他工作线程中窃取<ol><li>findrunnable函数（同时参与了gc和netpoll相关的事情）<ol><li>工作线程M的自旋状态<p>工作线程在从其它工作线程的本地运行队列中盗取goroutine时的状态称为自旋状态
把spinning标志设置成了true，同时增加处于自旋状态的M的数量，而盗取结束之后则把spinning标志还原为false，同时减少处于自旋状态的M的数量</p></li><li>窃取算法<p>遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列，然后从findrunnable返回，如果没有则继续遍历下一个p。
为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p，而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素</p></li></ol></li><li>找不到可以运行的g工作线程进入睡眠等待唤醒<ol><li>调用stopm<p>stopm的核心是调用mput把m结构体对象放入sched的midle全局空闲队列，然后通过notesleep(&amp;m.park)函数让自己进入睡眠状态

当其他工作线程发现有更多的goroutine需要运行时可以通过全局的m空闲队列找到处于睡眠状态的m，然后调用notewakeup(&amp;m.park)将其唤醒

M的全局空闲队列相当于m的对象池</p><ol><li>note机制<p>Runtime实现的一次性睡眠和唤醒机制

note的底层实现机制跟操作系统相关，不同系统使用不同的机制，比如linux下使用的futex系统调用，而mac下则是使用的pthread_cond_t条件变量，note对这些底层机制做了一个抽象和封装</p><ol><li>一个线程可以通过调用notesleep进入睡眠<p>notesleep函数调用futexsleep进入睡眠，需要用一个循环，是因为futexsleep有可能意外从睡眠中返回，所以从futexsleep函数返回后还需要检查note.key是否还是0，如果是0则表示并不是其它工作线程唤醒，只是futexsleep意外返回，需要再次调用futexsleep进入睡眠。

futexsleep调用futex函数进入睡眠，主要功能就是执行futex系统调用进入操作系统内核进行睡眠。

int64 futex(int32 *uaddr, int32 op, int32 val, struct timespec *timeout, int32 *uaddr2, int32 val2)

futex系统调用为我们提供的功能为如果 *uaddr == val 则进入睡眠，否则直接返回。需要在内核判断*uaddr与val是否相等，而不能在用户态先判断它们是否相等，原因在于判断*uaddr与val是否相等和进入睡眠这两个操作必须是一个原子操作，否则会存在一个竞态条件：如果不是原子操作，则当前线程在第一步判断完*uaddr与val相等之后进入睡眠之前的这一小段时间内，有另外一个线程通过唤醒操作把*uaddr的值修改了，这就会导致当前工作线程永远处于睡眠状态而无人唤醒它。而在用户态无法实现判断与进入睡眠这两步为一个原子操作，所以需要内核来为其实现原子操作</p></li><li>另一个线程可以通过notewakeup将其唤醒</li></ol></li><li>调用notesleep返回之后需要重新绑定一个p
返回findrunable函数继续寻找可运行goroutine</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li>调度器数据结构<ol><li>g结构体<p>goroutine的所有信息都保存在一个 g 对象中，当goroutine被调离CPU时，调度器负责把CPU寄存器的值保存在g对象的成员变量中，当goroutine被调度起来运行时，调度器负责把g对象的成员变量保存的寄存器的值复制到CPU的寄存器当中</p></li><li>m结构体<p>保存工作线程中的相关信息，如栈的起止位置、当前正在执行的goroutine以及是否空闲等状态信息，同时通过指针维护与p结构体对象的绑定关系。每个工作线程都有唯一一个m结构体对象与之对应</p><ol><li>通过线程本地存储TLS实现，定义私有全局变量（在不同的工作线程中使用相同的全局变量名访问不同的m结构体对象）</li></ol></li><li>p结构体<p>保存每个工作线程私有的局部goroutine运行队列，工作线程优先使用自己的局部运行队列，在必要情况下才去访问全局运行队列，尽量减少锁的冲突提高工作线程的并发性。每一个工作线程都会与一个p结构体对象的示例关联</p><ol><li>局部队列</li></ol></li><li>sched结构体<p>保存调度器自身的状态信息和保存goroutine的运行队列（全局运行队列）。每个go程序中schedt结构体只有一个实例对象，在源码中被定义成一个共享全局变量，访问队列中的数据需要互斥锁的操作。</p><ol><li>全局队列</li></ol></li></ol></li><li>循环调度<ol><li>shcedule函数<p>函数功能：通过调用globrunqget()和runqget()函数分别从全局运行队列和当前工作线程的本地运行队列中选取下一个需要运行的goroutine，如果这两个队列都没有需要运行的goroutine则通过findrunnalbe()函数从其它p的运行队列中盗取goroutine，一旦找到下一个需要运行的goroutine，则调用excute函数从g0切换到该goroutine去运行</p></li><li>excute函数<p>函数功能：第一个参数gp即是需要调度起来运行的goroutine
首先把gp的状态从_Grunnable修改为_Grunning，然后把gp和m关联起来，这样通过m就可以找到当前工作线程正在执行哪个goroutine</p></li><li>gogo函数<p>汇编代码函数功能： 
把gp.sched的成员恢复到CPU的寄存器完成状态以及栈的切换；
跳转到gp.sched.pc所指的指令地址（runtime.main）处执行。</p><ol><li>CPU执行权的转让和切换</li></ol></li><li>macll函数</li></ol></li><li>runtime其他函数</li></ol></body></html>