# 经典算法

## 蓄水池抽样

**思路**

- 假设数据流大小为N(不确定)，对每一个数据抽样保证是等概率即1/N
  - 遇到1，概率为1，保留第一个数。
  - 遇到2，概率为1/2，这个时候，1和2各1/2的概率被保留
  - 遇到3，3被保留的概率为1/3，(之前剩下的数假设1被保留)，2/3的概率 1 被保留，(此时1被保留的总概率为 2/3 * 1/2 = 1/3)
  - 遇到4，4被保留的概率为1/4，(之前剩下的数假设1被保留)，3/4的概率 1 被保留，(此时1被保留的总概率为 3/4 * 2/3 * 1/2 = 1/4)
- 以此类推，每个数被保留的概率都是1/N。

**算法**

- 假设数据流总数为N，抽样数为m，则抽样概率为m/N

- **第i个接收到的数据最后能够留在蓄水池中的概率**=**第i个数据进入过蓄水池的概率*****之后第i个数据不被替换的概率**（第i+1到第N次处理数据都不会被替换）

  1. 当**i<=m**时，数据直接放进蓄水池，所以**第i个数据进入过蓄水池的概率=1**。

  2. 当**i>m**时，在[1,i]内选取随机数d，如果d<=m，则使用第i个数据替换蓄水池中第d个数据，因此**第i个数据进入过蓄水池的概率=m/i**（反证法可以得到）。

  3. 当**i<=m**时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为
     $$
     (m / (m+1)) * (1/m) = 1 / (m+1)
     $$
     ，不被替换的概率为
     $$
     1-1/(m+1)=m/(m+1)
     $$
     。依次，第m+2次处理不替换掉第i个数据概率为
     $$
     1 - [ (m / (m+2)) * (1/m) ] =1 - [1/(m+2)] = (m+1)/(m+2)
     $$
     .........第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据**不被替换的概率**=
     $$
     m/(m+1)*(m+1)/(m+2)*...*(N-1)/N=m/N
     $$
     。

  4. 当**i>m**时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据**不被替换的概率**
     $$
     i/(i+1)*(i+1)/(i+2)*...*(N-1)/N=i/N
     $$
     

     结合第1点和第3点可知，当i<=m时，第i个接收到的数据最后留在蓄水池中的概率
     $$
     1*m/N=m/N
     $$
     当i>m时，第i个接收到的数据留在蓄水池中的概率
     $$
     m/i*i/N=m/N
     $$
     综上可知，**每个数据最后被选中留在蓄水池中的概率为m/N**。

  5. 

## 青蛙跳台阶

**题设**

- 青蛙一次可以跳一阶或两阶

**思路**

- 如果只有1级台阶，那显然只有一种跳法

- 如果有2级台阶，那么就有2种跳法，一种是分2次跳。每次跳1级，另一种就是一次跳2级

- 如果台阶级数大于2，设为n的话，这时我们把n级台阶时的跳法看成n的函数，记为
  $$
  f(n)
  $$
  ，第一次跳的时候有2种不同的选择：一是第一次跳一级，此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，即为
  $$
  f(n-1)
  $$
  ，二是第一次跳二级，此时跳法的数目等于后面剩下的n-2级台阶的跳法数目，即为
  $$
  f(n-2)
  $$
  ，因此n级台阶的不同跳法的总数为
  $$
  f(n) = f(n-1) + f(n-2)
  $$
  ，不难看出就是斐波那契数列

**题设**

- 青蛙一次可以跳上一阶、二阶......n阶

**思路**

- 如果台阶级数为n的话，这时我们把n级台阶时的跳法看成n的函数，记为
  $$
  f(n)
  $$
  
- 第一次跳的时候有n种不同的选择：若是第一次跳一级，此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，即为
  $$
  f(n-1)
  $$
  ,若是第一次跳m(m<n)级，此时跳法的数目等于后面剩下的n-m级台阶的跳法数目，即为
  $$
  f(n-m)
  $$
  ,若是第一次跳n级，此时跳法的数目等于1。所以
  $$
  f(n) = f(n-1) + f(n-2) + ... + f(n-m) + ... + f(2) + f(1) + 1
  $$
  因此
  $$
  f(n - 1) = f(n-2) + ... + f(n-m) + ... + f(2) + f(1) + 1
  $$
  

  两式相减得到
  $$
  f(n) = 2 * f(n-1)
  $$
  因此可以得到下面的结果
  $$
  f(n) = 2^{n-1}
  $$
  

## 最长回文字符串

**方法**

- 动态规划
- 中心扩展
- Manacher算法（添加 “#”）

## n人过桥

**方法**：贪心算法

**思路**：

- 策略一：第一个人 a[1] 带第n个人 a[n] 过去，然后第一个人回来再带第n-1个人 a[n-1] 过去

  耗时：a[n-1]+a[n]+2*a[1]

- 策略二：第一个人 a[1] 和第二个人 a[2] 先过去，第一个人回来，第n个人 a[n] 和第n-1个人 a[n-1] 过去，第二个人回来，第二个人和第一个人过去

  耗时：a[n]+a[1]+2*a[2]

- 只需要b比较这两种策略哪一种更快，采用更快的方式过桥即可

```c++
if(n==1)
{
  sum+=a[1];
	break;
}
else if(n==2)
{
  sum+=a[2];
  break;
}
else if(n==3)
{
  sum+=a[1]+a[2]+a[3];
	break;
}
else
{
  if(a[n-1]+a[1]<=2*a[2])//1分别带n n-1过桥
    sum+=a[n]+a[n-1]+2*a[1];
  else
    sum+=a[n]+a[1]+2*a[2];
  n-=2;
}
```

## 生成括号组合

**方法：**动态规划

- 状态转移：n个括号可以产生的组合由 “ ( p ) q ”，p+q=n-1，即由n个括号产生的组合可以由 n - 1 个括号产生的组合而来。

  p 为从 0 ~ n-1 个括号所组成的组合，q为从 n-1 ~ 0个括号所组成的组合，遍历一次可以得到无重复的由 n 个括号可以产生的所有组合